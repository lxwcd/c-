C++ 学习笔记

# 资源
## 书籍
> C++ Primer

## 视频
> [侯捷 c++ 视频](https://pan.baidu.com/s/1WR3y_Qfw7CssYlEC2tmISQ?pwd=jj2w)

## 网站
> [cplusplus](https://cplusplus.com/doc/tutorial/)
> [cppreference](https://en.cppreference.com/w/)

# C++ 基础语法

## 从源代码变成可执行文件的过程
在C++中，程序从源代码转变为可执行文件的过程涉及多个步骤，这些步骤通常由集成的开发环境(IDE)或者命令行工具自动完成。下面是这一编译过程的基本步骤：

1. **预处理（Preprocessing）**：
   - 在编译代码之前，预处理器采取源代码文件，执行以井号(#)开始的预处理指令。这包括处理宏定义、条件编译指令，以及包含头文件等操作。预处理器还会移除所有的注释。
   - 预处理完成后，生成一个预处理过的源代码文件，其中包含了所有通过#include指令包含进来的文件内容，宏展开的结果等。

2. **编译（Compilation）**：
   - 将预处理过的源代码转换成汇编语言。这个过程由编译器完成，它分析代码并生成与平台相关的汇编代码。
   - 在编译过程中，编译器也会检查语法错误，并可能对代码进行优化。

3. **汇编（Assembly）**：
   - 将编译器生成的汇编代码转换为机器语言指令，生成所谓的对象文件。这个过程由汇编器完成。

4. **链接（Linking）**：
   - 链接器将一个或多个对象文件以及所有需要的库文件链接在一起生成最终的可执行文件。
   - 在这个过程中，链接器解析并合并多个对象文件及库之间的符号引用，地址计算等，并生成可执行程序。
   - 有静态链接，它会把所有代码和库合并成一个文件；也有动态链接，它在运行时加载外部库文件。

5. **加载（Loading）**（通常不包括在编译过程，但为了完整理解包含在内）：
   - 当你运行一个程序时，加载步骤涉及操作系统将可执行文件加载到内存中，并开始执行程序。

这些步骤涉及到各种不同的文件类型和程序，例如源文件(`.cpp`), 头文件(`.h`), 对象文件(`.o` 或 `.obj`), 可执行文件(`.exe` 或在Unix系统中无拓展名)等。

这个过程不同系统和编译器可能会有所不同，但大体流程是一致的。同时现代的编译器可能会在这个过程中做很多优化操作。

### 预处理
C++编译过程中的预处理阶段涉及几个关键操作，预处理器会对源代码文件进行一系列文本替换和宏展开，准备好输入供编译器进一步处理。这些操作主要包括：

1. **宏定义的扩展**：
   - 将所有的宏定义(`#define`)扩展到相应的宏调用位置。宏可以是简单的文本替换或带有参数的复杂表达式。

2. **条件编译指令的处理**：
   - 根据预设的条件决定代码块是否编译，使用的指令包括`#if`, `#ifdef`, `#ifndef`, `#else`, `#elif`, 和`#endif`。

3. **文件包含指令的处理**：
   - 处理`#include`指令，将指定的文件内容插入到当前位置。标准库头文件通常用尖括号`< >`包围，而用户定义的头文件通常用双引号`" "`包围。

4. **预定义宏的替换**：
   - 一些宏是由编译器预定义的，如`__LINE__`（当前行号），`__FILE__`（当前文件名），`__DATE__`（编译日期），`__TIME__`（编译时间）等。

5. **注释的移除**：
   - 移除源代码中的所有注释，包括单行注释（`//`）和多行注释（`/* ... */`）。

6. **生成行控制信息**：
   - 预处理器会添加特殊的行控制标识，以帮助编译器追踪行号和文件名，这对于错误调试十分重要。

## translation phase
> [Phases of translation](https://en.cppreference.com/w/cpp/language/translation_phases#Phase_4)

C++ 的翻译过程是由一系列阶段组成的，每一个阶段都将执行一个特定的操作。这些操作都是按照顺序执行的，后一阶段的输入是前一阶段的输出。翻译的阶段包括以下步骤：

1. **阶段1：字符映射（Phase 1: Character Mapping）**  
此阶段会将程序中每一个文件的源字符集，即源代码文件中的所有字符，转换为基本源字符集。例如，一些特定的Unicode字符或者转义字符会被映射到相应的字符。

2. **阶段2：行拼接（Phase 2: Line Splicing）**  
在这个阶段，预处理器将把程序中所有以反斜杠（\）结束的行与下一行合并，生成物理行。

3. **阶段3：记号生成（Phase 3: Tokenization）**  
源文件会被分解为预处理记号和空白符序列，这包括空格、换行符、制表符等。在这个阶段，注释也会被替换为一个空格。

4. **阶段4：预处理（Phase 4: Preprocessing）**  
在这个阶段，预处理器将执行所有预处理指令，即以 `#` 开头的指令。例如，处理 `#include` 和 `#define` 等预处理指令。# 

5. **阶段5：字符串字面量与字符字面量的连接（Phase 5: String and Character Literals Concatenation）**  
在这个阶段，相邻的字符串字面量会被连接为单个字符串，并处理所有的转义序列。

6. **阶段6：翻译（Phase 6: Translation）**  
在这个阶段，源代码会被翻译成目标代码。如果有模板实例，它会在此阶段进行。

7. **阶段7：实例化（Phase 7: Instantiation）**  
对于包含模板的程序，它会在这个阶段根据具体的模板参数创建模板的实例。

8. **阶段8：链接（Phase 8: Linking）**  
编译器将所有的翻译单元，包括源代码文件和包含在程序中的所有头文件，以及链接到程序中的库，都链接在一起生成最终的可执行文件。

这些阶段构成了C++程序从源代码到最终可执行文件的统一过程。虽然在实践中，这些阶段可能会在一些复杂的方式下执行（例如，模板实例化可能会在编译或链接阶段进行），但是这个模型为C++的编译模型提供了一个概念框架。

"Phases of Translation"（翻译阶段）和从编译到连接的几个过程（预处理、编译、汇编、链接）虽然描述的都是C++源代码转换为可执行文件的过程，但它们所着重的层面和细节有所不同。

"Phases of Translation"更多地描述的是C++源代码从文本文件到可执行文件的转换过程中的逻辑层面和抽象过程。根据C++标准，这个过程被定义为8个阶段，它们详细描述了源代码是如何被处理和转换的。这些阶段包括字符映射、行拼接、记号生成、预处理、字符串字面量和字符字面量连接、翻译、实例化以及链接。这个分类着重于语言标准层面的规范描述，是对编译过程的严格按照C++标准的解释。

## 翻译阶段和从编译到链接阶段的区别
- **重点不同**："Phases of Translation"侧重于语言标准和源代码处理的逻辑阶段，而从编译到连接的过程则侧重于具体实现和操作细节。
- **细节层面不同**："Phases of Translation"提供了一个更为抽象和宏观的视角，注重于标准和规范，而编译到连接的过程更注重技术实现的细节和每个步骤的具体操作。
- **目的不同**："Phases of Translation"旨在为编译器的实现提供标准化的模板，而编译到连接的过程更多地被用于解释和教育，以帮助人们理解源代码是如何被转换为可执行文件的。

## 删除注释的阶段
删除注释虽然在 phase 3，而预处理在 phase 4，但因为在实际的编译器实现中，预处理的活动通常被认为是一个整体，包括宏替换、包含处理和注释去除等操作。但如果按照C++标准中定义的翻译阶段来考虑，这些活动实际是分布在几个不同的逻辑阶段。

尽管在传统的讨论和编译器的实际执行过程中，我们通常将移除注释视为预处理的一部分，但根据C++的翻译阶段来看，移除注释实际上是在预处理动作（第4阶段）之前，作为记号生成过程（第3阶段）的一部分完成的。

这种分区可能在理论上有其意义，以确保语言的规范性和各实现之间的一致性，但在日常使用和讨论中，人们往往会简单地将所有这些活动总称为预处理。

## 预处理指令
预处理指令是C++中一部分，在编译过程的最开始被处理。它们指导编译器在实际编译之前对源代码进行一些预处理。

### `#include`

这个指令告诉预处理器包含一个文件的内容。这通常用于包含库头文件或其他源文件。

```cpp
#include <iostream> // 包含标准输入输出流库
#include "myheader.h" // 包含用户定义的头文件
```

### `#define`
在 C++ 中，`#define` 指令是预处理器的一部分，用于定义宏。这意味着在编译之前，预处理器会将所有宏名称替换为其定义。`#define` 可以用来定义各种类型的常量，如整型、字符、字符串等。

#### 整型

```cpp
#define PI 3.14
```

这里定义了一个名为 `PI` 的宏，其值为 `3.14`。这个宏在预处理阶段会被直接替换为 `3.14`，因此它几乎不占用任何内存空间。

#### 字符

```cpp
#define NEWLINE '\n'
```

在这个例子中，我们定义了一个名为 `NEWLINE` 的宏，用来代表换行符。和之前一样，这个宏在编译期被替换成对应的值，内存占用微乎其微。

#### 字符串

```cpp
#define GREETING "Hello, World!"
```

这里，我们定义了一个包含字符串的宏 `GREETING`。在编译时，所有的 `GREETING` 实例将被替换为 `"Hello, World!"`。字符串常量通常被存储在程序的只读数据段中。

#### 复合类型定义

宏也可以用来定义更复杂的表达式或代码片段。

```cpp
#define SQUARE(x) ((x) * (x))
```

这个宏 `SQUARE` 接受一个参数，并计算其平方。它展示了如何将宏用作函数。但是需要注意的是，宏没有作用域的概念，也不进行类型检查，因此它们在复杂表达式中可能产生意想不到的副作用。

#### 可变参数宏
这样可以传递任意数量的参数给宏，`__VA_ARGS__` 会被替换为这些参数。

可变参数宏（Variadic Macros）是C++预处理器的一个特性，它允许宏接受可变数量的参数。这是在C++11及其之后的标准中支持的特性，使得宏能够更灵活地处理不同数量的输入参数。

使用 `...` 来指示宏定义中的可变部分，并且可以使用 `__VA_ARGS__` 宏来表示所有的可变参数列表。这使得开发人员可以书写接受任意数量参数的宏。

一个简单的日志宏，它接收可变数量的参数并打印：

```cpp
#include <iostream>

// 定义一个可变参数的宏，用来打印日志信息。
#define LOG(format, ...) printf(format, __VA_ARGS__)

int main() {
    // 使用宏来打印不同数量的参数
    LOG("This is a log message: %s\n", "Hello, World!");
    LOG("This is a log message with two parameters: %s %d\n", "Number", 1);

    return 0;
}
```

在这个例子中，我们定义了一个 `LOG` 宏，它可以接受一个字符串格式，然后是一个可变数量的参数，类似于 `printf` 的功能。`LOG` 宏首先接收一个格式字符串，然后是使用 `...` 表示的可变参数，它们在宏内部通过 `__VA_ARGS__` 引用。

##### 处理不同数据类型
可变参数宏通过使用 `...` 和 `__VA_ARGS__` 来处理不同类型的输入。在宏中，`...` 表示宏可以接受任意数量的参数，而 `__VA_ARGS__` 是一个特殊的宏，它表示所有传递给可变参数宏的参数列表。

要处理不同类型的输入，通常会结合使用格式化字符串（就像在 `printf` 函数中一样）与 `__VA_ARGS__`。这样做允许创建类似于标准C库函数 `printf` 的宏，它能够将不同类型的变量插入到字符串中去。

```cpp
#include <cstdio>

// 定义一个 LOG 宏，接收一个格式化字符串和可变参数
#define LOG(format, ...) printf(format, __VA_ARGS__)

int main() {
    int num = 10;
    float pi = 3.14f;
    const char* str = "example";

    // 使用宏来打印不同类型的参数
    LOG("Integer: %d, Float: %.2f, String: %s\n", num, pi, str);

    return 0;
}
```

上面的 `LOG` 宏可以接收不同类型的输入参数，比如 `int`、`float` 和 `const char*`，并且能够将它们格式化成字符串输出。

在实际使用时，应该要保证提供给宏的格式化字符串与传递的参数类型相匹配，因为预处理器不会进行类型检查，错误的匹配可能会导致未定义的行为。

##### 内存占用
在编译时，可变参数宏会随着宏展开，因此它们不会独立占用内存空间，而是会根据宏替换后的代码量来决定增加的内存消耗。

##### 初始化
与普通的宏一样，可变参数宏没有运行时的初始化过程，它们仅在编译阶段进行文本替换。

使用可变参数宏可以让宏的应用更加灵活，但是它们也继承了宏的缺点，比如类型不安全、可能出现的复杂的宏展开问题等。这些都是开发者在使用可变参数宏时需要注意的问题。

#### `##` 连接操作符
在宏定义中，`##` 操作符可以用来连接两个宏参数或宏参数与其他文本。它会删除连接符两边的空白，并将它们拼接成一个单一的标识符：

如使用 `##` 操作符连接两个令牌，以形成一个新的变量名。
```cpp
#include <iostream>

#define CONCAT(a, b) a##b

int main() {
    int myVariable = 10;
    int anotherVar = 20;

    // 使用 CONCAT 宏来连接 "my" 和 "Variable"，构成 "myVariable"
    std::cout << "myVariable: " << CONCAT(my, Variable) << std::endl;
    
    // 尝试另一个例子，连接 "another" 和 "Var"，构成 "anotherVar"
    std::cout << "anotherVar: " << CONCAT(another, Var) << std::endl;

    return 0;
}
```

最后的程序输出将会是：
```cpp
myVariable: 10
anotherVar: 20
```

这样，就成功地使用 `##` 操作符连接了两个令牌，并且利用这个特性来访问具体的变量。这个技巧在需要根据条件动态生成变量名或函数名时非常有用。

##### 注意事项
在使用 `##` 连接操作符时，需要注意以下几个方面：

1. **操作数必须是预处理器令牌**：`##` 操作符两边的操作数必须是有效的预处理器令牌。这意味着你不能使用它来连接不形成有效C++令牌的字符。

2. **生成的令牌必须是有效的**：通过 `##` 操作符连接生成的新令牌必须是编译器可以识别的有效令牌。比如，连接后形成的不是一个有效的标识符（变量名、函数名等），程序则会编译失败。

3. **使用中的空格处理**：`##` 操作符对两边的空白字符不敏感。无论你是否在 `##` 的两侧添加空格，结果都将是相同的。但是在编写宏时，良好的空格使用习惯有助于提高代码的可读性。

4. **防止宏展开错误**：在一些情况下，如果 `##` 的两边是宏参数，而这些参数自身也需要宏展开，可能会出现预处理结果不如预期的情况。为了确保宏参数在连接之前被正确地展开，你可能需要使用间接宏展开的技巧。

##### 间接宏展开
如果我们想要根据不同的条件，动态地生成变量名或者函数名。这时，我们就需要使用宏的展开特性了。但是，有时候我们直接使用宏，会发现它并没有像预期那样工作，尤其是在宏参数需要先展开成其他内容再进行连接的场合。这时，间接展开就显得非常有用。

首先定义两个宏，一个用于间接展开，一个是我们实际想要使用的宏：

```cpp
// 定义一个辅助宏，用于实现间接展开
#define CONCAT_HELPER(a, b) a##b

// 定义另一个宏，它利用上面的辅助宏来实现最终的功能
#define CONCAT(a, b) CONCAT_HELPER(a, b)
```

```cpp
#define FIRST_HALF Hello
#define SECOND_HALF World

// 假设我们想要定义一个变量名为 HelloWorld
```

如果我们直接使用 `##` 来连接 `FIRST_HALF` 和 `SECOND_HALF`，可能会因为宏参数没有正确地展开而失败。但是使用间接展开技术，则可以正确完成这个操作：

```cpp
// 使用间接展开宏
CONCAT(FIRST_HALF, SECOND_HALF)
```

在上面的代码中：

1. 调用 `CONCAT(FIRST_HALF, SECOND_HALF)` 意图是生成 `HelloWorld`。
2. 实际上，首先调用的是 `CONCAT_HELPER(FIRST_HALF, SECOND_HALF)`。
3. 在 `CONCAT_HELPER` 里，`a` 和 `b` 使用 `##` 连接之前，`FIRST_HALF` 和 `SECOND_HALF` 两个参数会首先被展开为 `Hello` 和 `World`。
4. 最后，`CONCAT_HELPER` 会把 `Hello` 和 `World` 连接成 `HelloWorld`。

这是一个非常有用的技巧，尤其是当宏的参数本身也是宏时。通过这种间接的方式，我们可以确保任何参数宏都会在连接之前被完全展开。这样不仅避免了预处理器相关错误，还提高了宏定义的灵活性和可用性。

#### `#` 字符串化操作符
在宏中，`#` 操作符会把跟随它的宏参数转换成一个字符串字面量：

```cpp
#define TO_STRING(x) #x
```

调用 `TO_STRING(123)` 会产生 `"123"`。

#### 初始化

使用 `#define` 定义的宏在预处理阶段就替换了，所以并不涉及运行时的初始化。这与变量初始化不同，宏没有存储位置，它们仅仅是文本替换。

#### 内存占用

由于 `#define` 定义的宏仅仅是文本替换，并不实际占用运行时内存。它们的"值"在编译时被插入到代码中，因此宏本身不会增加编译后程序的内存占用。

### `#undef`

取消定义宏。

```cpp
#undef PI
```

### `#if`, `#elif`, `#else`, `#endif`

这些指令用于条件编译。根据指定条件是否为真，可能会包括或排除代码部分。

```cpp
#define DEBUG 1

#if DEBUG
    std::cout << "Debug information";
#endif
```

### `#ifdef` 和 `#ifndef`

这些指令检查一个宏是否被定义了，如果是(`#ifdef`)或不是(`#ifndef`)，则编译接下来的代码。

```cpp
#ifndef PI
    #define PI 3.14
#endif
```

### `#error` 和 `#warning`

如果遇到这些指令，预处理器将分别显示错误或警告信息。

```cpp
#error This is an error message
```

### `#pragma`

特定于编译器的指令，用于控制编译器的特定功能。

```cpp
#pragma once // 防止头文件被包含多次
```

### `#line`

这个指令可以改变编译器认为的当前行号和文件名。

```cpp
#line 100 "newfilename.cpp"
```

这些指令在编写跨平台代码、调试、以及编码复杂应用时非常有用。在编译期间，预处理器会根据这些指令修改源码，然后才开始实际编译过程。

## 宏
C++宏是预处理器指令，用于在编译之前对源代码进行文本替换。宏提供了一种强大的方式来抽象代码和避免重复。

### 避免宏重复
使用 `#pragma once` 或者头文件保护（include guards）来避免头文件被多次包含：

```cpp
#ifndef MYHEADER_H
#define MYHEADER_H
// 头文件内容
#endif
```

### 宏的局限性
虽然宏功能强大，但也有一些缺点。宏只进行文本替换，没有类型检查，也不尊重作用域。过多使用宏可能会导致代码难以阅读和调试。

### 宏函数的缺陷
在C++中，过多地使用宏函数通常并不推荐，主要原因有以下几点：

1. **类型不安全**：宏进行的是文本替换，不会进行类型检查，这可能导致类型错误或不一致，而在编译时不会报错。

2. **调试困难**：宏展开后的代码在编译时插入到调用的地方，如果宏中存在错误，定位问题非常困难，因为编译器错误信息会指向展开后的代码，而不是宏定义本身。

3. **作用域问题**：宏没有作用域的概念，它在预处理阶段进行文本替换，而函数有清晰的作用域定义。

4. **可读性差**：宏函数可以进行复杂的文本替换，但这样的代码通常难以阅读和理解，特别是对于那些不熟悉宏定义的程序员。

5. **维护难度**：随着项目的增长，过多的宏定义会使代码库变得难以维护，特别是当宏进行复杂的操作，或者在多个文件中被重复定义时。

6. **侵入性强**：宏定义散布在代码中多个地方时，可能会无意中覆盖其他重要的代码片段，因为宏不考虑变量和函数的命名冲突。

由于以上原因，在现代C++编程实践中，建议尽可能使用模板、内联函数和常量代替宏。这些语言特性提供了更好的类型安全、更明确的作用域，以及更容易阅读和维护的代码。例如，模板可以用来处理在编译时需要决定的泛型编程问题，而内联函数可以在不牺牲性能的情况下提供函数替代宏的功能。

## 代码换行显示
1. 如果在一行中写了一个完整的语句，但是发现该行代码过长，希望在以下行继续编写，你可以在行尾用反斜杠(`\`)来表示要在下一行继续这一语句。
```cpp
int sum = 1 + 2 + \
3 + 4;
```

2. 另外，也可以在一行代码中间位置直接换行，这个位置最好在一个操作符的前面或后面，或者在括号内。
```cpp
int sum = 1 +
2 + 3 +
4;
```
或者：
```cpp
int product = (1 +
2) * (3 +
4);
```

## 字符串多行显示

### 1. 字符串连接
另一种实现多行字符串的方法是通过在编译时自动进行的字符串连接。在 C++ 中如果将两个或多个字符串字面量放置在一起，它们会自动连接成一个单独的字符串字面量。使用这种方式时，你可以简单地将每行字符串分别写在新的一行，这样代码会更加清晰。

```cpp
#include <iostream>

int main() {
    std::string multilineString = "This is the first line.\n"
                                   "This is the second line.\n"
                                   "This is the third line.";
    std::cout << multilineString << std::endl;
    return 0;
}
```

### 2. 使用 Raw String Literals（原生字符串字面量）
从 C++11 开始，C++ 引入了原生字符串字面量（Raw String Literals），使得编写包含多行的字符串字面量变得更简单。原生字符串字面量通过 `R"delimiter( [text] )delimiter"` 的形式使用，其中 `delimiter` 是一个可选的自定义分隔符，可以为空。使用原生字符串字面量时，你可以直接在字符串中加入新行，而无需手动添加 `\n`。

```cpp
#include <iostream>

int main() {
    std::string multilineString = R"(This is the first line.
This is the second line.
This is the third line.)";
    std::cout << multilineString << std::endl;
    return 0;
}
```

### 3. 在操作符或括号内换行
这种方法是在表达式的操作符后或在括号内换行，而不影响代码的逻辑结构。这样做可以让每一行的长度保持在合理的范围内，提高代码的可读性。
```cpp
std::string str = "这是一个非常非常长的字符串，" +
                  "我们需要将它分成多行显示，" +
                  "以提高代码的可读性。";
```

## gcc
> [gcc](https://gcc.gnu.org/)

- **gcc**：原本指 GNU C Compiler，用于编译 C 程序。随着时间的推移，gcc 发展成为一个编译器集合，支持多种编程语言，包括 C、C++、Objective-C、Fortran、Ada 和 Go 等。因此，gcc 也可以指代 GNU Compiler Collection。
- **g++**：是 gcc 的一部分，专门用于编译 C++ 程序。它可以理解 C++ 的语法和链接 C++ 程序需要的库。

1. **默认编译语言**：
   - **gcc**：默认为编译 C 程序。当使用 gcc 编译 C++ 程序时，需要明确指定使用 C++ 编译器，或者直接使用 g++。
   - **g++**：专门用于编译 C++ 程序。

2. **链接的库**：
   - **gcc**：当编译 C++ 程序时，不会自动链接 C++ 标准库，除非明确指定。
   - **g++**：编译 C++ 程序时会自动链接 C++ 标准库，例如 libstdc++。

3. **使用场景**：
   - **gcc**：适用于将多种语言混合在一个项目中时使用，例如 C 和 C++ 混合编程，你可以使用 gcc 处理 C 文件，而用 g++ 编译和链接 C++ 文件。
   - **g++**：专注于 C++ 程序的编译和链接。


## make 和 makefile
> [make](https://www.cs.tufts.edu/comp/15/reference/make/makefile.pdf)

如果程序很简单，可以直接用 gcc 进行编译和链接，但当一个工程复杂时，借助工具更方便，因此有了 make 工具。

`make` 和 `Makefile` 是 UNIX/Linux 系统中用于自动化构建程序的工具和文件。它们大大简化了编译和链接程序的过程，尤其是对于包含多个源文件的复杂项目。下面将详细介绍这两者。

`make` 是一个工具程序，它主要的作用是根据 `Makefile` 文件中定义的规则自动编译和链接程序。它检测源文件的修改时间，只重新编译那些自上次编译后被修改过的文件，从而避免了不必要的编译，加快了构建速度。`make` 的使用减少了人工干预，确保了构建过程的一致性和准确性。

`Makefile` 是一个文本文件，它包含了一系列的规则（rules）来告诉 `make` 如何构建程序。一个规则通常包括三个部分：目标（target）、依赖（dependencies）和命令（commands）。

- **目标**：你想要 `make` 构建的东西，通常是可执行文件或对象文件。
- **依赖**：目标文件依赖的文件，只有当依赖的文件比目标文件更新时，`make` 才会执行相应的命令。
- **命令**：构建目标所需执行的实际命令，比如编译源代码或链接对象文件。

一个简单的示例 `Makefile` 可能看起来像这样：
```makefile
all: program

program: main.o helper.o
    gcc main.o helper.o -o program

main.o: main.c
    gcc -c main.c

helper.o: helper.c
    gcc -c helper.c

clean:
    rm -f *.o program
```

在这个示例中，`all` 是一个自定义目标，它的依赖是 `program`，这意味着当你在命令行中运行 `make` 或 `make all` 时，`make` 将尝试构建 `program`。

`program` 是最终目标，它依赖于 `main.o` 和 `helper.o`。如果这些对象文件不存在，或者相关的 `.c` 文件比它们新，`make` 将会执行定义在 `program` 规则下的命令来生成或更新 `program`。

`main.o` 和 `helper.o` 是两个中间目标，用于保存中间编译结果。当 `main.c` 或 `helper.c` 被修改后，`make` 将重新编译它们。

最后，`clean` 是一个自定义目标，它没有依赖，用于清理构建产物，使项目回到初始状态。

通过使用 `make` 和 `Makefile`，开发者可以有效地管理和自动化他们的构建流程，特别是对于大型和复杂的项目。

make 是一个用于构建和编译程序的工具，它使用 makefile 来描述构建规则。makefile 是一个文本文件，其中包含一系列规则，用于编译和链接程序。

## cmake
> [cmake](https://cmake.org/cmake/help/latest/)

cmake 是一个跨平台的构建系统生成器，它不直接建立构建，而是生成标准化的构建文件，如 Unix 的 Makefile 或 Windows Visual Studio 的项目文件。cmake 使用 CMakeLists.txt 文件来定义构建过程，可以根据这个定义生成适用于不同编译系统的构建文件。因此，cmake 提供了一种高级的方法来定义和管理项目构建过程，使之能够在多个平台上以一致的方式构建。

`cmake` 基本上是为了简化和标准化 `Makefile` 的编写过程。使用传统的 `make` 工具时，开发者需要手动编写 `Makefile` 文件，这可能既复杂又易于出错，尤其是在大型项目或跨平台项目中。`CMakeLists.txt` 文件用更抽象的方式来定义构建规则，并且 `cmake` 工具可以根据这些抽象的规则生成具体平台或编译器所需的 `Makefile` 或其他构建脚本。

简单来说，`cmake` 提供了以下优势：
- **跨平台兼容性**：`cmake` 能够生成适用于多种操作系统和编译环境的构建文件，例如可以在 Linux 上生成 Unix 风格的 `Makefile`，在 Windows 上生成 `nmake` 文件或 Visual Studio 项目文件。
- **简化构建配置**：相比手写复杂的 `Makefile`，`cmake` 的 `CMakeLists.txt` 文件编写简单，易于理解和维护。
- **自动化侦测与配置**：`cmake` 能够检测系统的编译环境，自动查找依赖库，配置编译器选项等，使构建过程自动化度更高。

总的来说，`cmake` 是现代化的构建配置工具，它让跨平台的构建过程不再依赖于手动编写和维护复杂的 `Makefile`。

## nmake
> [nmake](https://learn.microsoft.com/en-us/cpp/build/reference/nmake-reference?view=msvc-170)

nmake 是 Microsoft 提供的一个版本的 make 工具，用于支持 Microsoft 的编译环境，类似于 Unix/Linux 下的 make。nmake 使用的是 Microsoft 特有的 Makefile 格式，与 Unix 下的 Makefile 存在一些差异。nmake 通常用于编译和构建在 Visual Studio 环境下开发的项目。

## qmake
> [qmake](https://doc.qt.io/qt-6/qmake-manual.html)

`qmake` 是一个由 Qt 开发的跨平台构建系统工具，专门用于简化 Qt 应用程序的开发和构建过程。`qmake` 能够根据项目的需求自动生成适合不同编译器和开发环境的 `Makefile` 文件，从而让开发者能够更专注于软件开发本身，而不是花费时间在配置构建环境上。

### 特点
1. **跨平台性**：`qmake` 能够在多个平台上生成对应的构建配置，包括 Windows、macOS、Linux 等。
2. **简化构建配置**：使用 `qmake`，开发者只需编写简单的 `*.pro` 或 `*.pri` 文件来描述项目的结构和构建设置，`qmake` 就能自动为你生成复杂的 `Makefile`。
3. **Qt 集成**：`qmake` 与 Qt 库紧密集成，能够自动处理 Qt 库的依赖和相关配置，极大简化了 Qt 应用的构建过程。

### 使用方法
- **安装**：通常 `qmake` 会随 Qt SDK 一起安装，确保 Qt 的安装路径被加入到系统的环境变量中，这样就可以在命令行中直接使用 `qmake` 命令了。
- **编写项目文件**：项目文件（通常是 `.pro` 文件）是 `qmake` 的核心，它描述了项目的结构、源文件、头文件、资源文件以及特定的构建配置等。
```qmake
TEMPLATE = app
TARGET = your_application
QT += core gui

HEADERS += mainwindow.h
SOURCES += main.cpp mainwindow.cpp
```
- **生成 Makefile**：在命令行中，导航到包含 `.pro` 文件的目录，运行 `qmake` 命令。`qmake` 将会根据 `.pro` 文件的内容生成对应平台的 `Makefile`。
```bash
qmake
```
- **构建项目**：生成 `Makefile` 之后，使用对应平台的 `make` 工具来构建项目：
```bash
make  # 在 Unix/Linux 或 macOS 上
nmake # 在 Windows 上，如果是使用 nmake
```

### 高级用法
`qmake` 也支持比较复杂的项目结构，允许自定义构建变量、条件编译、模板生成等高级功能。这些功能通过在 `.pro` 文件中编写更为复杂的配置来实现。

总而言之，`qmake` 是一个强大的工具，尤其适合于 Qt 应用的开发。通过自动化处理构建配置，它让开发者能够把精力更多地集中在实现应用程序的功能上。

## build 和 rebuild
在 Qt 工程中，首先需要编写好 `.pro` 文件，然后执行 `qmake` 生成 `Makefile`。但是，执行 `qmake` 仅仅是生成了构建工程所需的 `Makefile`，而实际上还需要执行构建命令（如 `make` 或在 Qt Creator 中的 build 按钮）来编译和链接代码生成可执行文件或库。

- **`qmake`**: 执行 `qmake` 会根据 `.pro` 文件中定义的配置来生成 `Makefile`。这个步骤不会编译代码，它仅仅是为后续的编译步骤准备所需的 `Makefile` 文件。

- **`build`**: 执行 build（无论是在命令行中的 `make` 命令还是在 Qt Creator 中的 build 按钮）会根据 `qmake` 生成的 `Makefile` 来编译源代码和资源，链接所需的库，并最终生成可执行文件或库文件。如果之前已经进行过一次构建，且源代码没有变化，build 命令可能不会重新编译所有的文件，只会编译那些自上次 build 以来已经发生变化的源文件。

- **`rebuild`**: 当你需要从头开始重新构建你的工程时，你会执行一个 rebuild。在 Qt Creator 中执行 rebuild 会先执行一个 clean 操作清除所有之前编译生成的文件，然后像执行 build 那样重新编译整个工程。重建是用来确保所有东西都是最新的，通常在修改了 project 文件或者其他一些构建配置的时候需要做这个操作。

总结一下，`qmake` 是用来生成 `Makefile` 文件的，而 `build` 是用 `Makefile` 来编译和链接生成最终的二进制文件，`rebuild` 则是完整地清除并重新构建整个项目。在日常开发中，你会频繁地进行 `build` 操作，而在工程配置变化后，你可能需要重新运行 `qmake`，并且在一些特定情况下执行 `rebuild`。

## 声明
> [declarations](https://en.cppreference.com/w/cpp/language/declarations)

在C++中，纯声明（不包含定义）是一种常用的实践，特别适用于向编译器介绍某个标识符（如变量、函数、类等）而不立即提供其完整的定义。这种方式特别有用于实现头文件和模块化编程，让编译器知道某个标识符的存在及其类型，但实现（定义）可能会在其他地方给出。

1. **函数声明（函数原型）**:
函数的声明（Function Declaration）告诉编译器函数的名字、返回类型以及参数（如果有的话），但不包括具体的函数实现。函数的定义（Function Definition）则包括了函数的具体实现。

在C++中，函数声明非常简单，仅仅需要指定函数的返回类型、函数名以及参数列表（如果有的话），通常以分号结尾。例如：

```cpp
int sum(int, int); // 函数声明
```

而函数的定义则需要提供函数的具体实现。如果函数声明后面紧跟着花括号 `{}` 和函数体，那么这就构成了函数的定义。在定义中编写具体的代码来实现函数的功能。例如：

```cpp
int sum(int a, int b) { // 函数定义
    return a + b;
}
```

在编写程序时，函数必须被定义一次，但可以被声明多次。通常在头文件中进行函数声明，在源文件中进行函数定义。这样做的目的是为了在链接程序的不同部分时，确保在调用函数之前它们已被声明。

当我们提到一个函数“有 `{}`”，就意味着函数体存在，这通常表示函数被定义了。即便函数体为空，例如：

```cpp
void doNothing() {} // 空函数体的函数定义
```

这仍然是一个函数定义，因为它提供了函数体（尽管函数体为空）。如果一个函数没有花括号 `{}`，就意味着它是一个声明，因为它没有提供函数体：

```cpp
void doNothing(); // 函数声明
```

2. **外部变量声明**:
在C++编程中，`extern`关键字非常重要，它用于声明一个变量或函数是在别处定义的，这意味着使用`extern`可以在多个文件之间共享全局变量和函数。

考虑一个项目，其中包含两个文件：`globals.cpp`和`main.cpp`。

- **globals.cpp**定义了一个全局变量。
- **main.cpp**想要访问在`globals.cpp`中定义的这个全局变量。

**globals.cpp:**
```cpp
// globals.cpp
int globalVariable = 42;  // 全局变量的定义
```

**main.cpp:**
```cpp
// main.cpp
#include <iostream>

extern int globalVariable;  // 使用extern声明外部变量

int main() {
    std::cout << "Global variable value: " << globalVariable << std::endl;
    return 0;
}
```

在这个例子中，我们在`globals.cpp`文件中定义了一个名为`globalVariable`的全局变量。然后，在`main.cpp`文件中，我们使用`extern`关键字声明了同名的全局变量，这表明该变量的定义在其他位置（即`globals.cpp`）。因此，当`main.cpp`访问`globalVariable`时，它实际上访问的是在`globals.cpp`中定义的变量。这就允许不同文件之间共享和访问同一个变量。

为了使上面的例子工作，需要编译两个文件并将它们链接在一起。使用g++的命令行示例如下：

```bash
g++ -c globals.cpp -o globals.o
g++ -c main.cpp -o main.o
g++ globals.o main.o -o myProgram
./myProgram
```

输出：
```
Global variable value: 42
```

使用`extern`关键字确保了在`main.cpp`中能正确访问在`globals.cpp`中定义的`globalVariable`变量，这展示了如何在C++中跨文件共享全局变量。

3. **类和结构体的前向声明**:
当你只需要知道一个类的存在而不需要知道类的细节时，你可以进行类的前向声明。这特别有用于处理循环依赖问题。
```cpp
class MyClass; // 类的前向声明
struct MyStruct; // 结构体的前向声明
```

4. **使用typedef声明类型别名**:
你可以声明一个类型的别名而不定义新类型，这对于简化复杂类型名称很有帮助。
```cpp
typedef unsigned long ulong; // 声明了一个unsigned long的别名为ulong
```

5. **声明模板**:
模板可以被声明但不立即定义，直到实例化时。
```cpp
template <typename T>
class MyTemplateClass; // 模板类的前向声明

template <typename T>
void myTemplateFunction(T); // 模板函数的声明
```

6. **使用extern "C"声明C语言链接**:
在C++中，当你想要声明一个函数遵循C语言的链接规则时，可以使用`extern "C"`。

```cpp
extern "C" void myCFunction(int); // 声明一个C语言函数
```

通过这些声明，可以让编译器在不需要完整定义的情况下对程序的不同部分进行编译，有助于模块化设计和减少编译依赖。这种做法在大型项目和库的设计中非常有用。

## 定义
> [Initialization](https://en.cppreference.com/w/cpp/language/definition)

在C++中，定义(Definition)是创建程序中使用的实体的过程。这些实体可以是变量、函数、类等。定义会为这些实体分配内存，并且可能会初始化它们。定义与声明(Declaration)是有区别的，声明只是告诉编译器某个标识符的存在，而定义则是为其分配存储空间。

### 变量定义
定义变量时，编译器会在内存中为此变量分配空间。

### 函数定义
> [function definition](https://en.cppreference.com/w/cpp/language/function#Function_definition)


### 类定义
> [class definition](https://en.cppreference.com/w/cpp/language/class#Class_definition)


## extern
在C++编程中，`extern`关键字非常重要，它用于声明一个变量或函数是在别处定义的，这意味着使用`extern`可以在多个文件之间共享全局变量和函数。

### `extern`的关键点

1. **声明而非定义**: 当你使用`extern`时，它告诉编译器相应的变量或函数在其他地方定义，而不是在当前位置创建一个新的实例。
   
2. **全局变量共享**: 在大型项目中，可能需要在不同的文件中访问相同的全局变量，`extern`使得在不同文件之间访问和修改同一个全局变量成为可能。

3. **避免重复定义错误**: 如果没有`extern`，在多个文件中声明同一个全局变量会导致重复定义错误。使用`extern`可以避免这个问题。

### 完整示例

考虑一个项目，其中包含两个文件：`globals.cpp`和`main.cpp`。

- **globals.cpp**定义了一个全局变量。
- **main.cpp**想要访问在`globals.cpp`中定义的这个全局变量。

**globals.cpp:**
```cpp
// globals.cpp
int globalVariable = 42;  // 全局变量的定义
```

**main.cpp:**
```cpp
// main.cpp
#include <iostream>

extern int globalVariable;  // 使用extern声明外部变量

int main() {
    std::cout << "Global variable value: " << globalVariable << std::endl;
    return 0;
}
```

在这个例子中，我们在`globals.cpp`文件中定义了一个名为`globalVariable`的全局变量。然后，在`main.cpp`文件中，我们使用`extern`关键字声明了同名的全局变量，这表明该变量的定义在其他位置（即`globals.cpp`）。因此，当`main.cpp`访问`globalVariable`时，它实际上访问的是在`globals.cpp`中定义的变量。这就允许不同文件之间共享和访问同一个变量。

### 编译链接

为了使上面的例子工作，需要编译两个文件并将它们链接在一起。使用g++的命令行示例如下：

```bash
g++ -c globals.cpp -o globals.o
g++ -c main.cpp -o main.o
g++ globals.o main.o -o myProgram
./myProgram
```

输出：
```
Global variable value: 42
```

使用`extern`关键字确保了在`main.cpp`中能正确访问在`globals.cpp`中定义的`globalVariable`变量，这展示了如何在C++中跨文件共享全局变量。